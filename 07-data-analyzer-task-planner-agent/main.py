from crewai import Agent, Task, Crew, Process
import json, os, sys

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils import Config
from utils.crew_utils import execute_analysis_with_retry, print_execution_summary

# Load schema metadata
with open("output/consolidated.json") as f:
    schema_data = json.load(f)

RETRIES = Config.get_retry_config()["retry_count"]
OUTPUT_RAW_DIR = Config.get_config()["output_raw_dir"]
llm_cfg = Config.get_llm()

task_planner_agent = Agent(
    role="SQL Data Task Analyst",
    goal="Generate two realistic analysis tasks per table which would help in generating synthetic data based on schema.",
    backstory="""You are an expert database analyst.
    You carefully read the schema, foreign keys, and columns given to you. You do not assume or fabricate database details.
    You only propose realistic tasks grounded in the actual schema.
    The tasks should be of medium complexity and should not perform high complex data analysis.
    Keep the task very concise, precise and deterministic.
    """,
    tools=[],  # no MCP tools needed
    verbose=True,
    llm=llm_cfg,
)

task_validator = Agent(
    role="SQL Task Validator",
    goal="Validate generated tasks against schema to ensure correctness.",
    backstory="""You are a strict validator.
    You check that tasks for valid tables/columns references from schema. 
    You do not assume or fabricate database details.
    If invalid, explain why.""",
    verbose=True,
    llm=llm_cfg,
)

task_generation = Task(
    description=f"""
    This is a task for SQL Data Task Analyst agent only.
    
    Here is the database schema:
    {json.dumps(schema_data, indent=2)}

    Generate exactly 2 realistic data analysis tasks per table.
    Rules:
    - Tasks must use only tables and columns from the schema.
    - Tasks must be medium complexity and should not perform high complex data analysis.
    - Must be relevant for generating synthetic data.
    - Keep tasks short and specific (e.g. "Fetch top 5 genres by movie count", "Min and max length of reviewtext" etc.).
    - Return ONLY a JSON array of task strings.
    """,
    expected_output="A JSON array of strings, each a realistic task.",
    agent=task_planner_agent,
)

validator_task = Task(
    description=f"""
    This is a task for SQL Task Validator agent only.

    Here is the database schema:
    {json.dumps(schema_data, indent=2)}

    Validate the tasks generated by the previous agent.
    - Keep only valid tasks.
    - Mark invalid ones with reason.
    - Return a JSON object:
      {{
            "validation_passed": true|false,
            "issues": [
                {{
                "type": "invalid_task|other",
                "table": "task",
                "details": "Explanation of the issue"
                }}
            ],
            "message": "<summary string>"
        }}
    """,
    expected_output="Strict JSON object with validation_passed, issues[], and message.",
    agent=task_validator,
)

# Crew = Analyst + Validator running sequentially
crew = Crew(
    agents=[task_planner_agent, task_validator],
    tasks=[task_generation, validator_task],
    process=Process.sequential,
    verbose=True,
)
print("‚úÖ Database Analysis Crew assembled")
print(f"üë• Crew members: {len(crew.agents)} agents")
print(f"üìù Total tasks: {len(crew.tasks)} tasks")

try:
    validation_result, analyst_result, validation_success, total_attempts = execute_analysis_with_retry(crew=crew, max_retries=RETRIES)

    os.makedirs(OUTPUT_RAW_DIR, exist_ok=True)
    output_file = os.path.join(OUTPUT_RAW_DIR, "tasks.json")

    if validation_success and analyst_result:
        with open(output_file, "w") as f:
            tables_json = json.loads(analyst_result)
            json.dump(tables_json, f, indent=2)
        print(f"üíæ Saved extracted tables to {output_file}")
    else:
        print(f"‚ö†Ô∏è Validation failed hence no {output_file} saved.")

    print_execution_summary(
        validation_result, analyst_result, validation_success, total_attempts
    )

except Exception as e:
    print(f"\n‚ùå Fatal error during analysis execution: {str(e)}")
    print("üí° Check that the MCP server is running and database is accessible")
    raise
